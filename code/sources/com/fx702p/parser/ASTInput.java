/* Generated By:JJTree: Do not edit this line. ASTInput.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/*EDITED*/

package com.fx702p.parser;

import java.util.*;

import com.fx702p.emulator.*;
import com.fx702p.parser.ASTLine.LineInfos;

public class ASTInput extends SimpleNode
{
  public ASTInput(int id)
  {
    super(id);
  }

  public ASTInput(Fx702pParser p, int id)
  {
    super(p, id);
  }


  /** Accept the visitor. **/
  @Override
  public Object jjtAccept(Fx702pParserVisitor visitor, Object data)
  {
    return visitor.visit(this, data);
  }

  public int getLineIndexInSourceCode()
  {
    return lineIndexInSourceCode;
  }

  public void setLineIndexInSourceCode(int aLineIndexInSourceCode)
  {
    lineIndexInSourceCode = aLineIndexInSourceCode;
  }

  public void addSubInstructionPosition(int aPosition, Node aNode)
  {
    subInstructionsBoundaries.add(new InstructionBoundary(aPosition));
    if (aNode != null)
    {
      subInstructionIndexByNode.put(aNode, subInstructionsBoundaries.size() - 1);
    }
  }
  public InstructionBoundary getSubInstructionBoundary(Node aNode)
  {
    Integer subInstructionIndex = subInstructionIndexByNode.get(aNode);
    if (subInstructionIndex != null)
    {
      return subInstructionsBoundaries.get(subInstructionIndex);
    }
    else
    {
      return null;
    }
  }

  public void visitAndResynchronize(Fx702pParserVisitor aVisitor, LineInfos aLineInfos)
  {
    for (Node node : children)
    {
      Integer instructionIndex = subInstructionIndexByNode.get(node);
      if (instructionIndex != null)
      {
        InstructionBoundary subInstructionBoundary = subInstructionsBoundaries.get(instructionIndex);
        subInstructionBoundary.begin -= aLineInfos.columnDelta;
      }
      node.jjtAccept(aVisitor, aLineInfos);
    }
  }

  public void resynchronizePositions(Fx702pBasicSourceCode aBasicSourceCode, LineInfos theLineInfos)
  {
    InstructionBoundary.resynchronizeInputOrPrintPositions(aBasicSourceCode, lineIndexInSourceCode, subInstructionsBoundaries, this, theLineInfos);
  }

  private int lineIndexInSourceCode;
  private Vector<InstructionBoundary> subInstructionsBoundaries = new Vector<InstructionBoundary>();
  private HashMap<Node, Integer> subInstructionIndexByNode = new HashMap<Node, Integer>();
}
/*
 * JavaCC - OriginalChecksum=ed3d40da0f49c73aa65a191931d4a946 (do not edit this
 * line)
 */
