/* Generated By:JJTree: Do not edit this line. ASTPrint.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/*EDITED*/

package com.fx702p.parser;

import java.util.*;

import com.fx702p.emulator.*;
import com.fx702p.parser.ASTLine.LineInfos;

public class ASTPrint extends SimpleNode
{
  public ASTPrint(int id)
  {
    super(id);
  }

  public ASTPrint(Fx702pParser p, int id)
  {
    super(p, id);
  }


  /** Accept the visitor. **/
  @Override
  public Object jjtAccept(Fx702pParserVisitor visitor, Object data)
  {
    return visitor.visit(this, data);
  }

  public int getLineIndexInSourceCode()
  {
    return lineIndexInSourceCode;
  }

  public void setLineIndexInSourceCode(int aLineIndexInSourceCode)
  {
    lineIndexInSourceCode = aLineIndexInSourceCode;
  }

  public InstructionBoundary getSubInstructionBoundary(PrintSubExpressionNode aNode)
  {
    Integer subInstructionIndex = subInstructionIndexByNode.get(aNode);
    if (subInstructionIndex != null)
    {
      return subInstructionBoundaries.get(subInstructionIndex);
    }
    else
    {
      return null;
    }
  }

  public void addSubInstructionPosition(int aPosition, PrintSubExpressionNode aNode)
  {
    subInstructionBoundaries.add(new InstructionBoundary(aPosition));
    subInstructionIndexByNode.put(aNode, subInstructionBoundaries.size() - 1);
  }

  public void visitAndResynchronize(Fx702pParserVisitor aVisitor, LineInfos aLineInfos)
  {
    if (children != null)
    {
      for (Node node : children)
      {
        Integer instructionIndex = subInstructionIndexByNode.get(node);
        if (instructionIndex != null)
        {
          InstructionBoundary subInstructionBoundary = subInstructionBoundaries.get(instructionIndex);
          subInstructionBoundary.begin -= aLineInfos.columnDelta;
        }
        node.jjtAccept(aVisitor, aLineInfos);
      }
    }
  }

  public void resynchronizePositions(Fx702pBasicSourceCode aBasicSourceCode, LineInfos theLineInfos)
  {
    InstructionBoundary.resynchronizeInputOrPrintPositions(aBasicSourceCode, lineIndexInSourceCode, subInstructionBoundaries, this, theLineInfos);
  }

  private int lineIndexInSourceCode;
  private Vector<InstructionBoundary> subInstructionBoundaries = new Vector<InstructionBoundary>();
  private HashMap<PrintSubExpressionNode, Integer> subInstructionIndexByNode = new HashMap<PrintSubExpressionNode, Integer>();
}
/*
 * JavaCC - OriginalChecksum=f57d8b2acb58396786c507e9f9fbb202 (do not edit this
 * line)
 */
